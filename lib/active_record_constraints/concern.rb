# frozen_string_literal: true

module ActiveRecordConstraints
  module Concern
    extend ActiveSupport::Concern

    included do
      class_attribute :constraints, instance_accessor: false,
        instance_predicate: false, default: []

      before_save do
        constraint_errors.clear
      end
    end

    class_methods do
      # Checks for an unique constraint in the given attributes.
      # The unique constraint works by relying on the database to check if the
      # unique constraint has been violated or not and, if so, it is converted
      # to an +Error+ and appended to the record errors.
      #
      # In order to use the uniqueness constraint, the first step is to define
      # an unique index in a migration:
      #  add_index(:users, :email, unique: true)
      #
      # With the constraint created, we are now able to use it calling
      # +has_unique_constraint :email+ inside our +User+ model so we can
      # convert unique constraint exceptions to record errors:
      #  User.create(email: "email@mail.com")
      #  user = User.create(email: "email@mail.com") #=> email already exists
      #  user.errors.messages #=> { email: ["has already been taken"] }
      #
      # For composite unique constraints, we should pass the list of all
      # attributes that composes the unique constraint. For example, if in a
      # migration we defined the unique constraint as the following:
      #  add_index(:users, [:email, :account_id], unique: true)
      # We would need to call with +has_unique_constraint [:email, :account_id]+
      # so we could infer the constraint name correctly:
      #  User.create(email: "email@mail.com", account_id: 1)
      #  user = User.create(email: "email@mail.com", account_id: 1)
      #  user.errors.messages #=> { email: ["has already been taken"] }
      # Note that the error key used was the first attribute used on the
      # +has_unique_constraint+ call. This behaviour can be changed by passing
      # the +key+ param.
      #
      # In cases when it is not possible to infer the constraint name, when
      # working with legacy databases for example, we can set the constraint
      # name explicitly like:
      #  has_unique_constraint :email, name: "legacy_email_unique_constraint"
      #
      # Please note that the error is only added after we hit the database, so
      # it will not be visible until all other validations pass. Also note that
      # validating the record will clear the error and it will not be added
      # again until we hit the database again.
      #
      # @param attributes [Symbol, Array<Symbol>] The unique constraint
      #  attributes
      # @param name [String] The unique constraint name. By default, the
      #  unique constraint name is inferred from the model table name and
      #  attributes (it is the same generated by default in a migration).
      # @param message [String] The message in case the unique constraint
      #  fails. Defaults the configured I18n key +:taken+.
      # @param key [Symbol] The key to which the error will be added to.
      #  Defaults to the first attribute given on the attribute list. It must
      #  be a record attribute name.
      def has_unique_constraint(attributes, name: nil, message: nil, key: nil)
        name ||= connection.index_name(table_name, column: attributes)
        key ||= Array(attributes).first

        constraint = Constraints.unique(name: name, message: message, key: key)

        add_constraint(constraint)
      end

      # Checks for a check constraint on the given attribute.
      # The check constraint works by relying on the database to check if the
      # check constraint has been violated or not, and, if so, it is converted
      # to an +Error+ and appended to the record errors.
      #
      # In order to use the check constraint, the first step is to define an
      # check constraint in a migration:
      #  add_check_constraint(:products, "price > 0", name: "price_check")
      # With the constraint created, we are now able to use it calling
      # +has_check_constraint :price, name: "price_check+ inside our +Product+
      # model so we can convert check constraint exceptions to record errors:
      #  product = Product.create(price: -10)
      #  product.errors.messages #=> { price: ["is invalid"] }
      #
      # Please note that the error is only added after we hit the database, so
      # it will not be visible until all other validations pass. Also note that
      # validating the record will clear the error and it will not be added
      # again until we hit the database again.
      #
      # @param attribute [Symbol] The check constraint attribute
      # @param name [String] The check constraint name
      # @param message [String] The message in case the check constraint
      #  fails. Defaults the configured I18n key +:invalid+.
      #
      def has_check_constraint(attribute, name:, message: nil)
        constraint = Constraints.check(
          name: name,
          message: message,
          key: attribute
        )

        add_constraint(constraint)
      end

      # Checks the association field exists usings a foreign key constraint.
      # 
      # The foreign key constraint works by relying on the database to check if
      # the associated data exists or not. This is useful to guarantee that a
      # child will only be created if the parent exists in the database too.
      #
      # In order to use the foreign key constraint, the first step is to define
      # an foreign key constraint in a migration:
      #  add_foreign_key(:articles, :authors)
      # With the constraint created, we are now able to use it calling
      # +has_association_constraint :author+ inside our +Article+ model so we
      # can convert foreign key constraint exceptions to record errors:
      #  article = Article.create(author_id: 1) #=> assuming an Author with ID 1 doesn't exist
      #  article.errors.messages #=> { author_id: ["must exist"] } 
      #
      # The foreign key constraint name can be fetched automatically or can be
      # configured with the +name+ paramater.
      #
      # Please note that the error is only added after we hit the database, so
      # it will not be visible until all other validations pass. Also note that
      # validating the record will clear the error and it will not be added
      # again until we hit the database again. 
      #
      # @param attribute [Symbol] The association name
      # @param name [String] The foreign key name. Fetched from the database
      #  automatically by default.
      # @param message [String] The message in case the check constraint
      #  fails. Defaults the configured I18n key +:required+.
      #
      def has_association_constraint(association, name: nil, message: nil)
        name ||= fetch_foreign_key_name(association)

        constraint = Constraints.foreign_key(
          name: name,
          message: message,
          key: association
        )

        add_constraint(constraint)
      end

      private

      def add_constraint(constraint)
        self.constraints += [constraint]
        around_save(constraint, prepend: true)
      end

      def fetch_foreign_key_name(attribute)
        reflection = reflect_on_association(attribute)

        fk_constraint = connection.send(
          :foreign_key_for,
          table_name,
          to_table: reflection.table_name
        )

        fk_constraint.name
      end
    end

    def constraint_errors
      @constraint_errors ||= ActiveModel::Errors.new(self)
    end
  end
end
